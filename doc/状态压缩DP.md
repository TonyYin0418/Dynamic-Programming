# 状态压缩 DP

## 状态压缩

### 定义

​		状态压缩一般是将一个较小的集合内每个元素的状态通过特定的计算方法，转换为单个整数。这样的转换必须是双射。

​		在信息学竞赛中，状态的压缩和解压缩一般由二进制运算完成。究其主要原因，一方面是因为二进制可以很直接的表达一个元素集合内每个元素选中或不选中的状态，如二进制串 $01001$ 可以表示一个大小为 $5$ 的集合 $S$ 中第 $2$、$5$ 个元素被选中，第 $1$、$3$、$4$ 个元素未被选中的状态。另一方面则是因为计算机在存储数据时是以二进制方式存储，直接在二进制下对数据进行处理和计算往往比其他进制要快的多。**（是不是可以列个数字啥的）**

### 位运算

在二进制下对数据的处理和计算与数学中常用的加减乘除和逻辑运算略有不同，下面是对几类位运算的定义解释和约定。

* 与（`&`）：$A$ 和 $B$ 的按位与运算中，对 $A$ 和 $B$ 二进制下的每一位的值进行数学中的逻辑与运算，得到结果中对应位的值。

* 或（`|`）：$A$ 和 $B$ 的按位或运算中，对 $A$ 和 $B$ 二进制下的每一位的值进行数学中的逻辑或运算，得到结果中对应位的值。

* 取反（`~`）：$A$ 的按位取反运算中，对 $A$ 二进制下的每一位的值进行数学中的逻辑非运算，得到结果中对应位的值。

* 异或（`^`）：$A$ 和 $B$ 的按位异或计算中，对 $A$ 和 $B$ 二进制下的每一位的值进行如下计算：

  | A    | B    | A $\oplus$ B |
  | ---- | ---- | ------------ |
  | 0    | 0    | 0            |
  | 0    | 1    | 1            |
  | 1    | 0    | 1            |
  | 1    | 1    | 0            |

  得到结果中对应位的值。

* $A$ 的第 $i$ 位表示 $A$ 在二进制下从最低往最高位数第 $i+1$ 位，即 $\frac{A}{2^i}$ 除以 $2$ 所得余数。

* 左移（`<<`），右移（`>>`）：`x<<y` 表示 $x\times 2^y$，`x` 的第 $i$ 位为 `(x<<y)` 的第 $i+y$ 位，`(x<<y)` 的 $0\sim (y-1)$ 位均为 $0$。`x>>y` 表示 $\frac{x}{2^y}$，`x` 的第 $i$ 位（$i\ge y$）为 `(x>>y)` 的第 $i-y$ 位。

设全集为 $\Omega$，$|\Omega|=n$，用 $n$ 位二进制整数 $x$ 描述 $\Omega$ 的一个子集 $S$，那么 $x$ 的第 $i-1$ 位为 $1$ 则表示 $\Omega$ 中第 $i$ 个元素属于 $S$，为 $0$ 则表示 $\Omega$ 中第 $i$ 个元素不属于 $S$。基于此，对于数学中对集合之间的运算和关系的命题，位运算也有对应计算方式。

* $A$ 与 $B$ 交集：`A&B`。对于表示第 $i+1$ 个元素是否在交集中的第 $i$ 位，该位值为 $1$ 当且仅当 $A$ 的第 $i$ 位为 $1$ 且 $B$ 的第 $i$ 位为 $1$，即 $A$ 包含第 $i+1$ 个元素且 $B$ 包含第 $i+1$ 个元素。
* $A$ 与 $B$ 并集：`A|B`。对于表示第 $i+1$ 个元素是否在并集中的第 $i$ 位，该位值为 $1$ 当且仅当 $A$ 的第 $i$ 位为 $1$ 或 $B$ 的第 $i$ 位为 $1$，即 $A$ 包含第 $i+1$ 个元素或 $B$ 包含第 $i+1$ 个元素。
* $A$ 的补集：设 `O=((1<<n)-1)`，这样有 `O` 的 $0$ 到 $n-1$ 位均为 $1$，则 $A$ 的补集为`O^A`。对于表示第 $i+1$ 个元素是否在补集中的第 $i$ 位，因为 $O$ 第 $i$ 位为 $1$，因此该位为 $1$ 当且仅当 $A$ 的第 $i$ 位为 $0$，即 $A$ 不包含第 $i+1$ 个元素。
* $A/B$：`A^(A&B)`。对于表示第 $i+1$ 个元素是否在 $A/B$ 中的第 $i$ 位，该位值为 $1$ 当且仅当 $A$ 第 $i$ 位为 $1$ 且 $A\cap B$ 第 $i$ 位为 $0$。
* $p:$ $A$ 是 $B$ 的子集：`(A|B)==B`。若该表达式为真，那么对于第 $i$ 位，若 $B$ 第 $i$ 位为 $0$，则 $A$ 的第 $i$ 位为 $0$，若 $B$ 第 $i$ 位为 $1$，则 $A$ 的第 $i$ 位可取 $0/1$。即第 $i$ 个元素若不属于 $B$，则第 $i$ 个元素也不属于 $A$，命题 $p$ 为真。

## 状态压缩 DP

​		为满足 DP 的无后效性，存储对应值的索引往往需要包括可以描述该阶段状态的全部信息。而对于一类需要记录整个集合内每个元素状态的问题，朴素的对某一数组指针进行中括号运算在程序中略显乏力，设计的状态往往会冗长且转移拖沓，因此状态压缩优化状态就成为了更优的选择。

​		以一类经典的 NP 问题，旅行商问题（TSP）为例，设计传统的动态规划状态需要描述每一个点是否被到达过，因此描述需要 $n$ 维，其中 $n$ 为点数。$n$ 若不为常数，以动态的维数来实现 DP 的转移本身就较为困难，而就算假设 $n$ 为常数，例如 $6$，状态也需写成 $f(0/1,0/1,0/1,0/1,0/1,0/1)$，转移时枚举转移前状态和转移后状态更是需要 $7$ 个循环以上。而采取状态压缩，将每一个点是否被到达过表示为映射到的整数第 $i$ 位是否为 $1$，则状态只需写成 $f(S)$，转移最少只需 $2$ 个循环。

### 状态压缩优化状态设计的应用

#### 互不侵犯（P1896）

##### 题目描述

在国际象棋中，国王能攻击它上、下、左、右、左上、左下、右上、右下八个方向上附近各一个格子，共 $8$ 个。

现在在 $n\times n$ 的国际象棋棋盘上摆放 $k$ 个国王，使他们互不攻击，试求共有多少种摆放方案。

$1\le n\le 9,0\le k\le n\times n$

##### 解题思路

定义 $f[i][j][S]$ 表示从第 $1$ 行摆放到第 $i$ 行，已经摆放了 $j$ 个国王，第 $i$ 行每个格子摆放状态为 $S$ 的合法摆放方案数。其中 $S$ 的第 $i$ 位为 $1$ 则表示此行从左往右数第 $i+1$ 个格子摆放了国王，反之则没有摆放国王。

判断单行状态 $S$ 单独出现是否合法，考虑判断 `(S&(S<<1))==0` 是否为真。若为真则代表对于任意 $i$，`S&(S<<1)` 的第 $i$ 位均为 $0$，意味着 $S$ 第 $i$ 位为 $1$ 和 $S$ 的第 $i-1$ 位为 $1$ 不同时成立，即没有在同一行摆放左右相邻的国王。

判断两个状态 $S_1$、$S_2$ 是否可以作为合法的相邻两行出现，考虑判断 `((S1&S2)||(S1&(S2<<1))||(S1&(S2>>1)))==0` 是否为真。假设为假，那么如下三条至少存在一条为真

* `(S1&S2)` 存在一位 $i$ 使得其值为 $1$，则 $S_1$ 第 $i$ 位为 $1$ 且 $S_2$ 第 $i$ 位为 $1$，即上下相邻，不合法；
* `(S1&(S2<<1))` 存在一位 $i$ 使得其值为 $1$，则 $S_1$ 第 $i$ 位为 $1$ 且 $S_2$ 第 $i-1$ 位为 $1$，即互为左下和右上的关系，不合法；
* `(S1&(S2>>1))` 存在一位 $i$ 使得其值为 $1$，则 $S_1$ 第 $i$ 位为 $1$ 且 $S_2$ 第 $i+1$ 位为 $1$，即互为左上和右下的关系，不合法。

这三条判断和单行是否合法的判断覆盖了所有可能的不合法情况，提供了 $O(1)$ 的计算方法。而 C++ 中 `__builtin_popcount(x)` 函数可以以近似 $O(1)$ 的效率计算 $x$ 二进制中 $1$ 的个数，以下简写为 `pc(x)`。

转移考虑从小到大枚举 $i\in[1,n]$，枚举 $j\in[0,k]$，枚举合法单行状态 $S_1\in[0,2^n)$、$S_2\in[0,2^n)$。在 $S_1$ 和 $S_2$ 可以作为合法的相邻两行出现时，有转移
$$
f[i][j+pc(S_2)][S_2]:=f[i][j+pc(S_2)][S_2]+f[i-1][j][S_1]
$$
初始状态为 $f[0][0][0]=1$，即没有填任何行时，仅在没有摆放任何国王且该行为空时存在一个方案。最终答案为
$$
Ans=\sum_{S\in[0,2^n)}f[n][k][S]
$$
即摆放了所有行，一共摆放了 $k$ 个国王，最后一行为任意状态的合法方案总和。整体时间复杂度为 $O(nkA+2^n)$，空间复杂度为 $O(nk2^n)$，其中 $A$ 为合法单行 $S_1$、$S_2$ 组成的不同合法相邻行个数，在 $n\le 9$ 时满足 $A\le 683$。

##### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,f[15][105][(1<<9)];
#define pc __builtin_popcount
int main(){
	cin>>n>>k;
	f[0][0][0]=1;
	for(int i=1;i<=n;i++){
		for(int S1=0;S1<(1<<n);S1++){
			if((S1&(S1<<1))==0){
                for(int S2=0;S2<(1<<n);S2++){
                    if(((S2&(S2<<1))==0)&&(((S1&S2)||(S1&(S2<<1))||(S1&(S2>>1)))==0)){
                        for(int j=0;j<=k;j++){
                            f[i][j+pc(S2)][S2]+=f[i-1][j][S1];
                        }
                    }
                }
            }
		}
	}
	long long ans=0;
	for(int S=0;S<(1<<n);S++)ans+=f[n][k][S];
	cout<<ans<<endl;
	return 0;
}
```

#### 寿司晚宴（P2150）

##### 题目描述

给定 $n$，设全集为 $\Omega=\{x\mid x\in[2,n]\}$。求有多少个不同的二元组 $(A,B)$，满足：

* $A,B$ 为 $\Omega$ 的子集；
* 对于任意 $x\in A,y\in B$，有 $\gcd(x,y)=1$。

答案对 $p$ 取模。

$2\le n\le 500$。

##### 解题思路

显然不能对 $500$ 以内的 $95$ 个质因数进行状态压缩和转移，因为这样时空复杂度至少是 $O(2^{95})$ 的，远超一般计算机每秒算力。

但可以发现对于任意 $x\in[2,500]$，$x$ 分解质因数后包含的 $\gt19$ 的质因子不会超过 $1$ 个，$\le19$ 的质因数仅 $8$ 个，可以状态压缩。而我们只关注 $\Omega$ 中每个数分解质因数后的质因子集合，因此一个数 $i$ 可以被表示为二元组 $(p_i,S_i)$，其中 $p_i$ 表示 $i$ 分解质因数后 $\gt19$ 的质因子，没有则为 $1$；$S_i$ 表示 $i$ 分解质因数后包含的 $\le19$ 的质因子的集合，$S_i$ 共 $8$ 位，第 $x$ 位为 $1$ 则表示从小到大第 $x+1$ 个质数是 $i$ 的因子，反之则不是。

按二元组第一位给 $n-1$ 个数分组后，可以看出除 $p_i=1$ 的组，其余组不能即有元素属于 $A$、又有元素属于 $B$。且将 $A$ 集合中的所有元素二元组第二位按位或后，$B$ 集合对应值与之进行按位与应为 $0$。

因此可以对整体设计状态，对 $p_i=1$ 的组合 $p_i\gt1$ 的组分别进行转移。

设 $f[a][b]$ 表示 $A$ 集合中所有元素第二位按位或的值为 $a$，$B$ 集合中所有元素第二位按位或的值为 $b$ 且没有任意一个元素同时属于 $A,B$，没有任意一组中即有元素属于 $A$、又有元素属于 $B$ 的方案数。

* 对于 $p_i=1$ 的组，有
  $$
  \begin{aligned}
  f'[a|S_i][b]&:=f[a][b]\\
  f'[a][b|S_i]&:=f[a][b]\\
  \end{aligned}
  $$
  其中 $f'$ 为新的 $f$ 数组，在枚举完 $a,b$ 后替换 $f$。即 $f$ 数组不是边枚举 $a,b$ 边更新的。下同。

* 对于每一组，设 $dp1[a][b]$ 为当前组没有任一元素在 $B$ 中的方案数， $dp2[a][b]$ 为当前组没有任一元素在 $A$ 中的方案数，有
  $$
  \begin{aligned}
  dp1'[a|S_i][b]&:=dp1[a][b]\\
  dp2'[a][b|S_i]&:=dp2[a][b]\\
  \end{aligned}
  $$
  在这一组更新初，将 $dp1,dp2$ 的值赋为 $f$。在更新完这一组所有元素后，有
  $$
  f'[a][b]=dp1[a][b]+dp2[a][b]-f[a][b]
  $$
  因为这一组即没有元素在 $A$ 中，也没有元素在 $B$ 中会被算重。

最后有
$$
Ans=\sum_{S_1\cap S_2=\varnothing}f[S_1][S_2]
$$
整体时间复杂度为 $O(n2^{16})$，空间复杂度为 $O(2^{16})$。

##### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=505,maxs=(1<<8),prn=8,pr[prn]={2,3,5,7,11,13,17,19};
inline int read(){
    int x=0,f=1,ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-48;ch=getchar();}
    return x*f;
}
int n,mod;
struct num{int v,key,S;}a[maxn];
bool cmp(num a,num b){return a.key==b.key?a.v<b.v:a.key<b.key;}
int f[maxs][maxs],dp1[maxs][maxs],dp2[maxs][maxs],_dp1[maxs][maxs],_dp2[maxs][maxs];
inline void upd(int &x,int y){x=x+y;if(x>=mod)x-=mod;}
int main(){
    n=read();mod=read();
    for(int i=1;i<n;i++){
        a[i].v=a[i].key=i+1;
        for(int j=0;j<prn;j++){
            if(!(a[i].key%pr[j]))a[i].S|=(1<<j);
            while(!(a[i].key%pr[j]))a[i].key/=pr[j];
        }
    }
    sort(a+1,a+n,cmp);
    f[0][0]=1;
    int st=1;
    while(a[st].key==1){
        memset(_dp1,0,sizeof(_dp1));
        for(int s1=0;s1<(1<<prn);s1++)
        for(int s2=0;s2<(1<<prn);s2++){
            upd(_dp1[s1|a[st].S][s2],f[s1][s2]);
            upd(_dp1[s1][s2|a[st].S],f[s1][s2]);
        }
        for(int s1=0;s1<(1<<prn);s1++)
        for(int s2=0;s2<(1<<prn);s2++)
            upd(f[s1][s2],_dp1[s1][s2]);
        st++;
    }
    for(int i=st;i<n;i++){
        if(a[i].key!=a[i-1].key)
        for(int s1=0;s1<(1<<prn);s1++)
        for(int s2=0;s2<(1<<prn);s2++)
            dp1[s1][s2]=dp2[s1][s2]=f[s1][s2];
        memset(_dp1,0,sizeof(_dp1));
        memset(_dp2,0,sizeof(_dp2));
        for(int s1=0;s1<(1<<prn);s1++)
        for(int s2=0;s2<(1<<prn);s2++){
            upd(_dp1[s1|a[i].S][s2],dp1[s1][s2]);
            upd(_dp2[s1][s2|a[i].S],dp2[s1][s2]);
        }
        for(int s1=0;s1<(1<<prn);s1++)
        for(int s2=0;s2<(1<<prn);s2++)
            upd(dp1[s1][s2],_dp1[s1][s2]),
            upd(dp2[s1][s2],_dp2[s1][s2]);
        if(a[i].key!=a[i+1].key)
        for(int s1=0;s1<(1<<prn);s1++)
        for(int s2=0;s2<(1<<prn);s2++)
            f[s1][s2]=((dp1[s1][s2]+dp2[s1][s2])%mod-f[s1][s2]+mod)%mod;
    }
    int ans=0;
    for(int s1=0;s1<(1<<prn);s1++)
    for(int s2=0;s2<(1<<prn);s2++)
        if((s1&s2)==0)upd(ans,f[s1][s2]);
    cout<<ans<<'\n';
    return 0;
}
```

